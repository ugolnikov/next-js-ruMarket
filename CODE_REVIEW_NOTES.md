# Замеченные ошибки и возможные оптимизации

## Критичные / потенциальные ошибки

### 1. `src/lib/db.js`

1. **`updateCartItemQuantity` всегда ставит количество `1`**
   - Строки ~61–83: при обновлении используется `data: { quantity: 1 }`, при этом аргумент `quantity` функции игнорируется.
   - Это делает невозможным реальное изменение количества товара в корзине.
   - **Как исправить:** использовать переданное значение `quantity` (и при необходимости ограничить его минимумом 1):
     - `data: { quantity: Math.max(1, quantity) }`.

2. **Несогласованность типов ID с Prisma (BigInt vs Number)**
   - В схеме (`prisma/schema.prisma`) ID почти всех моделей — `BigInt`.
   - В этом модуле и других местах кода ID часто передаются как `Number` или `String`, без приведения к `BigInt`.
   - Это может привести к runtime‑ошибкам Prisma (`Argument id: Got invalid value ...`), если в `where` придёт `number`, а ожидается `BigInt`.
   - **Как исправить:** везде, где ID берётся из сессии/параметров, приводить к `BigInt` при обращении к БД, а наружу (в JSON) возвращать строки/числа.

### 2. `src/lib/auth.js` (NextAuth)

1. **Нет проверки на отсутствие пользователя в сессии‑callback**
   - Строки 54–78: `const user = await prisma.user.findUnique(...)`, далее идёт обращение к `user.id`, `user.email` и т.д., но нет проверки `if (!user)`.
   - При удалённом/изменённом пользователе это приведёт к падению сессии (`Cannot read properties of null`).
   - **Как исправить:**
     - Если `!user`, либо возвращать исходную `session`, либо делать `signOut`, но не обращаться к полям `user`.

2. **Смешение типов ID (Number / BigInt / String)**
   - В `authorize` возвращается `id: Number(user.id)`.
   - В `jwt`‑callback `token.id = user.id` (т.е. уже `Number`).
   - В `session`‑callback делается `BigInt(token.id)` и далее `session.user.id = String(user.id)`.
   - В других местах кода (например, API‑роуты) сравнение и where‑условия делают с `Number` или строкой.
   - **Как оптимизировать / исправить:**
     - В токене хранить ID как строку (`token.id = String(user.id)`), везде при обращении к БД делать `BigInt(token.id)`.
     - В объект сессии также всегда класть строку.

### 3. `src/app/api/dashboard/---[dashboardId]---/route.js`

1. **Неправильное сравнение ID пользователя сессии и целевого пользователя**
   - Строки 25–30: `const targetUserId = Number(id)` и затем `if (session.user.id !== targetUserId) { ... }`.
   - В `session.user.id` (см. `auth.js`) лежит строка (или число), а `targetUserId` — `number`. Строгое сравнение `!==` почти всегда будет `true` при разных типах.
   - В результате, даже владелец не сможет получить доступ — будет 403 Forbidden.
   - **Как исправить:**
     - Привести оба значения к одному типу, лучше к `BigInt` или хотя бы к строке:
       - `if (BigInt(session.user.id) !== BigInt(targetUserId)) { ... }`.

2. **Использование `Number(id)` для `BigInt` полей**
   - Везде в этом файле для `where: { id: targetUserId }` используется `Number`, тогда как в схеме `id` — `BigInt`.
   - Это может ломать Prisma‑запросы и на больших значениях ещё и терять точность.
   - **Как исправить:** использовать `BigInt(id)` как и в других API‑роутах (`[userId]`).

3. **Ненадёжное получение ID из URL**
   - Строка 20: `const id = request.url.split('/').pop()` — чувствительно к трейлинг‑слешу и query‑параметрам.
   - **Как исправить:** использовать `new URL(request.url).pathname.split('/').pop()` или маршрутные параметры, как в `[userId]` роуте.

### 4. `src/app/(app)/dashboard/page.js`

1. **Потенциальный краш при форматировании даты верификации**
   - Строки ~207–212: `const date = new Date(user?.verification_approved_at)` и сразу `date.toLocaleDateString(...)`.
   - Если `verification_approved_at` равен `null`/`undefined`, `date` будет `Invalid Date`, и `toLocaleDateString` бросит `RangeError`.
   - **Как исправить:**
     - Перед форматированием проверять валидность даты, либо не вычислять `verif_date`, пока поле пустое.

2. **Вычисление даты до проверки `user`**
   - `if (!user || ordersLoading) return <Loader />` идёт после вычисления `date`/`verif_date`, поэтому компонент может упасть ещё до проверки `!user`.
   - **Как исправить:** сначала проверить `if (!user || ordersLoading)`, а затем вычислять производные значения вроде `verif_date`.

3. **Лишний `console.log(user)` в продакшене**
   - Строка 19: отладочный лог лучше удалить или ограничить dev‑окружением.

4. **Неиспользуемый `isLoading` из `useAuth`**
   - Деструктурируется, но не используется — просто мусор в коде.

### 5. `src/components/ProductForm.js`

1. **Конфликт имён переменных и краш при загрузке дополнительных изображений**
   - В `handleAdditionalImageUpload` объявляется локальная переменная `const formData = new FormData()`, а затем используется `formData.image_urls` (строка 131).
   - У объекта `FormData` нет свойства `image_urls`, в итоге выражение `const newImageUrls = [...formData.image_urls]` приведёт к ошибке `TypeError: undefined is not iterable`.
   - Причина — затенение стейта `formData` из `useState` локальной переменной с тем же именем.
   - **Как исправить:**
     - Переименовать локальную переменную, например в `uploadFormData`:
       - `const uploadFormData = new FormData()` и далее `uploadFormData.append('file', file)`.
     - Для работы с URL‑ами использовать именно стейт: `const newImageUrls = [...formData.image_urls]` (из хука).

2. **`useEffect` для `additionalFileInputRefs` с пустым списком зависимостей**
   - Строки 147–150: инициализация `additionalFileInputRefs` и `uploadingImages` выполняется только один раз, на основе начального значения `formData.image_urls`.
   - При добавлении новых URL через `addImageUrl` вы вручную пушите ref, но код становится хрупким и легко рассинхронизировать длину массивов.
   - **Оптимизация:**
     - Либо полностью управлять массивами refs в одном месте (без `useEffect`), либо вычислять их от `formData.image_urls` в `useEffect` с зависимостью `[formData.image_urls.length]`.

### 6. `src/app/api/user/profile/route.js`

1. **Смешение типов ID (BigInt vs String) при обновлении профиля**
   - Строка 63: `where: { id: BigInt(session.user.id) }` — корректно, но требует, чтобы `session.user.id` была всегда строкой/числом, приводимым к BigInt.
   - В других местах кода есть места, где ID сравниваются как числа или строки — важно привести всё к одной модели (см. пункт про `auth.js` и `---[dashboardId]---`).

## Оптимизации и улучшения качества кода

### 1. Дублирующаяся и разная инициализация Prisma (`src/lib/db.js` и `src/lib/prisma.js`)

- Сейчас есть два файла с созданием `PrismaClient` (`db.js` и `prisma.js`), причём во втором включены логи.
- Это увеличивает риск того, что часть кода будет использовать один инстанс, а часть — другой, и усложняет конфигурацию.
- **Рекомендация:**
  - Оставить один файл (например, `prisma.js`) с созданием клиента и везде импортировать `prisma` только из него.
  - В `db.js` оставить только высокоуровневые методы (`db.findUser`, `db.getCart` и т.п.), но использовать внутри общий `prisma`.

### 2. Единообразная работа с BigInt ID во всём проекте

- Сейчас ID пользователя/заказа/товара где‑то приводятся к `Number`, где‑то к `BigInt`, где‑то хранятся в сессии как строка.
- Это типичная причина странных багов при сравнении ID и запросах к БД.
- **Рекомендация:**
  - Внутри БД и в `where` всегда использовать `BigInt`.
  - В JWT/сессии хранить ID как строку.
  - На границах (API‑ответы, props в компоненты) приводить ID к `number` или `string` и соблюдать единообразие.

### 3. Повторная логика загрузки корзины (`useAuth` и `useCart`)

- И `useAuth`, и `useCart` используют `useSWR` с ключом `'/api/cart'` и почти одинаковой логикой обработки 401.
- Это означает дублирование запроса/кэша и усложняет сопровождение.
- **Оптимизация:**
  - Выделить один хук (например, `useCart`) и использовать его везде, где нужна корзина.
  - В `useAuth` можно просто реэкспортировать данные/методы из `useCart`, если нужно.

### 4. Общая оптимизация `src/app/(app)/layout.js` и `useAuth`

- В `(app)/layout.js` вызывается `useAuth({ middleware: 'guest' })`, а в `(app)/dashboard/layout.js` — `useAuth({ middleware: 'auth' })`.
- Это приводит к двум вызовам хука с SWR внутри разных компонентов и, соответственно, к дублирующим запросам.
- **Оптимизация:**
  - Подумать, действительно ли нужен вызов `useAuth` в общем `AppLayout`, или достаточно только в защищённых страницах.

### 5. Мелкие улучшения

- `src/hooks/auth.js` — в `useEffect` стоит добавить `router` в список зависимостей, чтобы удовлетворить линтеру и избежать потенциальных проблем.
- Удалить неиспользуемые переменные (`isLoading` в `Dashboard`, `cartError` из `useAuth`, если он нигде не возвращается).
- Проверить и по возможности удалить закомментированный код (например, блок с дополнительными изображениями в `ProductForm`), либо довести его до рабочего состояния.

---

## Дополнительные замечания по API-роутам

### 7. `src/app/api/cart/[cartId]/route.js`

1. **Несоответствие имени параметра динамическому сегменту**
   - В роутах Next `app/api/cart/[cartId]/route.js` параметр должен называться `cartId`, но в `PUT`/`PATCH` используется `const id = params.id`.
   - В итоге `id` будет `undefined`, и обновление количества упадёт или всегда будет работать некорректно.
   - **Как исправить:** использовать `params.cartId` (и по возможности приводить к `BigInt`, а не `parseInt`).

2. **Дублирование логики обновления количества и устаревшая привязка к `db.updateCartItemQuantity`**
   - Есть и `PUT`, и `PATCH`, оба делают примерно одно и то же.
   - При этом `db.updateCartItemQuantity` внутри `src/lib/db.js` всегда пишет `quantity: 1` (см. раздел про `db.js`), игнорируя переданное количество.
   - **Рекомендация:**
     - Либо оставить один метод (`PATCH`), либо чётко разделить ответственность.
     - Исправить `db.updateCartItemQuantity`, чтобы он реально использовал `quantity`.

3. **Смешение `db` и прямого `prisma` в одном файле**
   - Вверху импортируются и `db`, и `prisma` из того же файла `lib/db`.
   - Для единообразия лучше использовать один слой доступа к данным (либо только `db`, либо только `prisma` из `lib/prisma`).

### 8. `src/app/api/cart/route.js`

1. **Использование `session.user.id` как есть в `where` при том, что в БД `BigInt`**
   - `where: { user_id: session.user.id }` при том, что в схеме `user_id: BigInt`.
   - Если в сессии хранится строка / `number`, Prisma ожидает `BigInt`, и возможны ошибки типов.
   - **Как исправить:** явно приводить к `BigInt(session.user.id)` в `where` (и аналогично в `POST`/`DELETE`).

2. **Слепое приведение `seller_id` к `Number` при сериализации**
   - Строка 34: `seller_id: Number(item.products.seller_id)` — если поле `seller_id` `null`, будет `0`, что может ввести в заблуждение.
   - В других файлах вы уже используете шаблон `field ? Number(field) : null`.
   - **Рекомендация:** выровнять сериализацию и здесь: `seller_id: item.products.seller_id ? Number(item.products.seller_id) : null`.

### 9. `src/app/api/favorites/route.js` и `[productId]/route.js`

1. **Ещё одно место с `user_id: session.user.id` без приведения к `BigInt`**
   - И в `GET`, и в `POST`, и в `[productId]/DELETE` используется `user_id: session.user.id` при том, что `user_id` в схеме — `BigInt`.
   - **Как исправить:** использовать `BigInt(session.user.id)` или, как минимум, выровнять это с остальным кодом.

2. **Ненадёжное извлечение `productId` из URL в `[productId]/route.js`**
   - Строка 15: `const productId = request.url.split('/').pop()`.
   - Чувствительно к закрывающему `/` и query‑параметрам; у вас уже есть примеры с использованием `params` в других файлах.
   - **Рекомендация:** заменить на вариант с `params.productId` (как в seller/admin‑роутах).

### 10. `src/app/api/products/route.js`

1. **`POST` использует `db.createProduct`, но `db` не импортирован**
   - Вверху только `import { prisma } from '@/lib/db'`, а в `POST` вызывается `db.createProduct(data)`.
   - Это либо вызовет `ReferenceError: db is not defined`, либо TypeScript/линтер уже ругается.
   - **Как исправить:**
     - Либо импортировать `db` (`import { db } from '@/lib/db'`),
     - Либо вместо `db.createProduct` использовать `prisma.product.create` по аналогии с другими роутами.

2. **Несогласованность с seller/admin роутами по созданию товара**
   - В `seller/products` и `admin/products` при создании товара явно задаются `seller_id`, `is_published`, т.д.
   - Здесь логика другая (`db.createProduct`), возможно, устаревшая.
   - **Рекомендация:** привести все точки создания товара к одному месту (одна функция в `db` или один общий хэлпер), чтобы поведение не расходилось.

### 11. `src/app/api/products/[productId]/route.js`

1. **Опять `Number(id)` для `BigInt` полей**
   - Во всех `where: { id: Number(id) }` используется `Number`, при том, что в схеме `id: BigInt`.
   - **Как исправить:** `where: { id: BigInt(id) }` и соответствующее сравнение seller‑ID также делать через `BigInt`.

2. **Проверка прав с потенциально разными типами**
   - Строка 88: `if (Number(product.seller_id) !== session.user.id && session.user.role !== 'admin')`.
   - Здесь один операнд `number`, другой — что‑то из сессии (`string`/`number`). При несогласованности типов возможны странные сравнения.
   - **Как исправить:** приводить оба к одному типу (например, `BigInt(product.seller_id) !== BigInt(session.user.id)`).

3. **Использование `request.url.split('/').pop()` для ID**
   - Как и в других местах, лучше опираться на `params.productId`.

### 12. `src/app/api/orders/[orderNumber]/route.js`

1. **`db.updateOrder(orderNumber, data)` — нет такой функции в `db.js`**
   - В `db` есть `updateOrderStatus(id, status)`, но нет универсального `updateOrder(orderNumber, data)`.
   - Это приведёт к ошибке в рантайме.
   - **Как исправить:**
     - Либо добавить реализацию `db.updateOrder`,
     - Либо заменить на прямой вызов `prisma.order.update` по `orderNumber`.

2. **Смешение `BigInt` и `userId` в сравнении доступа**
   - `const userId = BigInt(session.user.id)` и проверка `order.userId !== userId` — корректно, но нужно убедиться, что `order.userId` действительно `BigInt`, а не уже сериализованное значение (сейчас возвращается «сырое» из Prisma, так что ок, но это надо держать в голове при изменении `db.getOrder`).

### 13. `src/app/api/orders/route.js`

1. **Опора на `db.getAllOrders` при отсутствии реализации**
   - Вызывается `db.getAllOrders()` для админа, но в `src/lib/db.js` такой функции нет.
   - **Как исправить:** реализовать `db.getAllOrders` (по аналогии с `getUserOrders`) или заменить на прямой запрос через `prisma.order.findMany`.

### 14. `src/app/api/seller/orders/route.js`

1. **Фильтрация по `seller_id: session.user.id` без учёта `BigInt`**
   - В where‑условии и при фильтрации `BigInt(item.product.seller_id) === BigInt(session.user.id)` — в фильтрации всё ок, но в where используется `seller_id: session.user.id` (тип из сессии).
   - **Как исправить:** `seller_id: BigInt(session.user.id)`.

2. **Дублирующая логика сериализации заказов**
   - Очень похожий код сериализации есть в других order‑роутах.
   - **Оптимизация:** вынести `serializeOrder` в один общий модуль/утилиту.

### 15. `src/app/api/admin/settings/route.js`

1. **Создание собственного `PrismaClient` вместо использования общего `prisma`**
   - Здесь создаётся `const prisma = new PrismaClient()`, а во всём остальном проекте используется `@/lib/db` / `@/lib/prisma`.
   - Это может привести к множественным подключениям к БД и проблемам в dev‑окружении (утечки, слишком много соединений).
   - **Как исправить:** использовать общий клиент из `src/lib/prisma.js` или `src/lib/db.js`.

2. **Нет проверки прав (доступа администратора)**
   - Роут меняет глобальную настройку комиссии, но не проверяет, что вызывающий пользователь — админ.
   - **Как минимум**, `PUT` точно должен требовать администратора; для `GET` — на усмотрение.

### 16. `src/app/api/admin/statistics/route.js` и `src/app/api/admin/stats/route.js`

1. **Очень похожий функционал двух разных роутов**
   - Оба отдают админскую статистику (users/orders/products/revenue и т.п.), но с разной детализацией.
   - **Оптимизация:**
     - Либо объединить их в один роут с параметрами (`detail=basic|full`),
     - Либо явно документировать, какой из них «новый», а какой — «legacy», чтобы потом убрать дубликат.

2. **Отладочный `console.log(session)` в `admin/stats`**
   - Желательно удалить или обернуть в условие `if (process.env.NODE_ENV !== 'production')`.

### 17. `src/app/api/admin/users/[userId]/route.js`

1. **Сравнение self‑delete через `Number(userId) === session.user.id`**
   - При том, что везде ID — `BigInt`/строка, такое сравнение может быть ненадёжным.
   - **Как исправить:** использовать единый формат, например `BigInt(userId) === BigInt(session.user.id)`.

2. **Обновление пользователя без фильтрации полей**
   - В `PUT` всё, что приходит в `data`, по сути без доп. валидации передаётся в Prisma (кроме явного деструктурирования).
   - При расширении схемы легко появится возможность менять поля, которые вы не планировали выставлять наружу.
   - **Рекомендация:** явно формировать объект `updateData` только из разрешённых полей (аналогично тому, как сделано в `admin/orders/[orderId]/route.js`).

### 18. `src/app/api/validate/inn/route.js`

1. **Нет таймаута и обработки неуспешного ответа Dadata**
   - Сейчас код просто делает `await fetch(...)` и `await response.json()` без проверки `response.ok`.
   - В случае 4xx/5xx от Dadata вы получите не тот формат или ошибку парсинга.
   - **Как улучшить:**
     - Проверить `if (!response.ok)` и вернуть читаемую ошибку на клиент.

2. **Жёсткая зависимость от переменной окружения без fallback‑проверки**
   - Если `DADATA_API_KEY` не задан, запрос всё равно пойдёт, но всегда будет неавторизованным.
   - **Рекомендация:**
     - Если ключа нет — сразу возвращать ошибку `500` с понятным сообщением (`DADATA_API_KEY is not configured`).

### 19. Прочие моменты

- `src/app/api/dashboard/number/[dashboardId]/route.js` — файл пустой, но роут существует. Стоит либо реализовать, либо удалить, чтобы не плодить «висячие» endpoints.
- В нескольких местах (`admin/verifications`, `dashboard/user/[userId]`) логика верификации продавца дублируется и легко может разъехаться при доработках. Имеет смысл выделить общую функцию для смены статуса верификации.

---

## UX и производительность (клиентские компоненты)

### 1. Листинг товаров и фильтры (`src/components/Products.js`, `ProductFilters.js`)

1. **Двойная логика поиска (компонент `Search` + встроенный инпут в `Products`)**
   - Есть отдельный компонент `Search`, но на главной странице используется собственный поисковый инпут с debounce. Возможна путаница и дублирование логики.
   - **Рекомендация:** либо использовать единый компонент `Search` с debounce, либо полностью убрать неиспользуемый.

2. **Анимации на каждой карточке + `whileInView` могут быть тяжёлыми на слабых устройствах**
   - Для каждой карточки товара используется `framer-motion` с анимацией появления и `viewport={{ once: true }}`.
   - На больших списках (много товаров, несколько страниц) это даёт ощутимую нагрузку на CPU/GPU.
   - **Рекомендация:**
     - Ограничить анимации до простого fade‑in без сложных задержек, либо отключать анимации на мобильных / при слабых устройствах.

3. **Фильтр цены с двумя range‑слайдерами и двумя `number`‑полями**
   - Удобно, но есть риск нелогичных состояний (min > max и наоборот). Логика в `handlePriceChange` это учитывает, но UX все равно может быть запутанным.
   - **Рекомендация:** рассмотреть единый ползунок диапазона или более простой UI (предустановленные диапазоны).

4. **Загрузка состояния (Loader)**
   - При первом рендере, если `isLoading && !products`, показывается полноэкранный `Loader` с `min-h-screen`. На последующих пагинациях / фильтрациях список просто переключается без skeleton‑состояния.
   - **Улучшение:** добавить skeleton‑карточки вместо полного спиннера, чтобы страница «не прыгала».

### 2. Кнопка «В корзину» (`src/components/AddToCartButton.js`)

1. **Каждая кнопка инициализирует свои `useAuth` и `useCart`**
   - На листинге много карточек товара, каждая кнопка вызывает `useAuth({ middleware: 'guest' })` и `useCart()`. Это множит количество SWR‑хуков и потенциальных ререндеров.
   - **Рекомендация:**
     - Хранить пользователя/корзину на уровне страницы/контекста и передавать нужные данные/колбэки в кнопку.

2. **Логика «добавить/удалить» в одной кнопке**
   - UX‑wise это удобно, но текст «✓ Добавлено!»/«Удалено!» завязан на `isInCart`, и при быстром клике возможно странное мигание статуса.
   - **Улучшение:** краткий toast/notification, а сама кнопка отображает стабильное состояние («В корзине», «В корзину»).

### 3. Навигация и шапка (`src/components/Navigation.js`)

1. **Повторный подсчёт `cartCount` по всему массиву при каждом обновлении `cart`**
   - Сейчас это просто `cart.items.length`, что ок, но на будущее (если добавятся количества) можно считать суммарное количество (`reduce`).

2. **Неиспользуемый `isLoading` из `useCart`**
   - Можно использовать его, чтобы показывать skeleton‑состояние иконки корзины, а не просто 0.

3. **Responsive‑меню дублирует пункты навигации**
   - Desktop и mobile‑навигация содержат дублирующиеся списки ссылок; при изменениях нужно править в двух местах.
   - **Оптимизация:** вынести список ссылок в массив и рендерить его и для desktop, и для mobile‑версии.

### 4. Детали заказа (`src/components/OrderDetails.js`)

1. **Использование `window` прямо в `useEffect` без проверки окружения**
   - Компонент помечен `'use client'`, так что сейчас это безопасно, но при переносе логики часть кода может быть переиспользована не только на клиенте.
   - **Рекомендация:** оборачивать доступ к `window` в проверку `if (typeof window !== 'undefined')` для надёжности.

2. **Повторный вызов `fetchOrder` при каждом изменении `orderNumber`**
   - Корректно, но можно обернуть `fetchOrder` в `useCallback` и добавить отмену запросов при размонтировании (если потом потребуется SSR/конкурентный рендеринг).

3. **Lightbox грузится всегда**
   - Импорт `yet-another-react-lightbox` и стилей происходит на уровне компонента и попадает во все бандлы, где компонент используется.
   - **Оптимизация:** динамически импортировать lightbox через `next/dynamic` с `ssr: false`, чтобы не тянуть его на страницы, где он не нужен до клика.

### 5. Loader (`src/components/Loader.js`)

1. **Глобальный `min-h-screen` везде, где нужен просто локальный спиннер**
   - Сейчас `Loader` растягивает контейнер на полный экран. Внутри карточек/маленьких блоков это может ломать вёрстку.
   - **Рекомендация:**
     - Сделать два варианта: полноэкранный `PageLoader` и компактный `InlineLoader`.

---

Файл можно и дальше дополнять по мере нахождения новых проблем. Если нужно, могу помочь ещё и с конкретным планом исправления (что чинить в первую очередь и как разбить на задачи).
